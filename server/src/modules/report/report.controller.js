const asyncHandler = require("../../utils/asyncHandler");
const ApiError = require("../../utils/ApiError");
const ApiResponse = require("../../utils/ApiResponse");
const Booking = require("../booking/booking.model");
const Complaint = require("../complaint/complaint.model");
const User = require("../user/user.model");
const Payment = require("../payment/payment.model");
const Hostel = require("../hostel/hostel.model");
const logger = require("../../config/logger");

/**
 * Report Controller
 * Generates various reports and analytics
 */

/**
 * Booking Report
 * Shows booking statistics over time
 */
const getBookingReport = asyncHandler(async (req, res) => {
  const { startDate, endDate, hostelId } = req.query;

  // Build date filter
  let dateFilter = {};
  if (startDate || endDate) {
    dateFilter.createdAt = {};
    if (startDate) {
      dateFilter.createdAt.$gte = new Date(startDate);
    }
    if (endDate) {
      dateFilter.createdAt.$lte = new Date(endDate);
    }
  }

  let filter = { ...dateFilter };
  if (hostelId) {
    filter.hostel = hostelId;
  }

  // Total bookings
  const totalBookings = await Booking.countDocuments(filter);

  // Bookings by status
  const bookingsByStatus = await Booking.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$status",
        count: { $sum: 1 },
      },
    },
  ]);

  // Monthly bookings
  const monthlyBookings = await Booking.aggregate([
    { $match: filter },
    {
      $group: {
        _id: {
          year: { $year: "$createdAt" },
          month: { $month: "$createdAt" },
        },
        count: { $sum: 1 },
      },
    },
    { $sort: { "_id.year": 1, "_id.month": 1 } },
  ]);

  // Cancellation rate
  const cancelledCount = await Booking.countDocuments({ ...filter, status: "cancelled" });
  const cancellationRate = totalBookings > 0 ? ((cancelledCount / totalBookings) * 100).toFixed(2) : 0;

  // Revenue per hostel
  const revenueByHostel = await Booking.aggregate([
    { $match: { ...filter, status: { $in: ["completed", "checked_out"] } } },
    {
      $group: {
        _id: "$hostel",
        revenue: { $sum: "$totalPrice" },
        bookings: { $sum: 1 },
      },
    },
    {
      $lookup: {
        from: "hostels",
        localField: "_id",
        foreignField: "_id",
        as: "hostelInfo",
      },
    },
    {
      $project: {
        hostelName: { $arrayElemAt: ["$hostelInfo.name", 0] },
        revenue: 1,
        bookings: 1,
      },
    },
    { $sort: { revenue: -1 } },
  ]);

  const report = {
    summary: {
      totalBookings,
      cancelledCount,
      cancellationRate: `${cancellationRate}%`,
    },
    byStatus: bookingsByStatus,
    monthly: monthlyBookings,
    revenueByHostel,
  };

  logger.info(`Booking report generated by ${req.user._id}`);

  return res.status(200).json(
    new ApiResponse(200, report, "Booking report generated successfully")
  );
});

/**
 * Complaint Report
 * Shows complaint statistics and resolution metrics
 */
const getComplaintReport = asyncHandler(async (req, res) => {
  const { startDate, endDate, hostelId, category, priority } = req.query;

  // Build filter
  let filter = {};
  if (startDate || endDate) {
    filter.createdAt = {};
    if (startDate) {
      filter.createdAt.$gte = new Date(startDate);
    }
    if (endDate) {
      filter.createdAt.$lte = new Date(endDate);
    }
  }
  if (hostelId) {
    filter.hostel = hostelId;
  }
  if (category) {
    filter.category = category;
  }
  if (priority) {
    filter.priority = priority;
  }

  // Total complaints
  const totalComplaints = await Complaint.countDocuments(filter);

  // Complaints by status
  const complaintsByStatus = await Complaint.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$status",
        count: { $sum: 1 },
      },
    },
  ]);

  // Complaints by category
  const complaintsByCategory = await Complaint.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$category",
        count: { $sum: 1 },
      },
    },
  ]);

  // Complaints by priority
  const complaintsByPriority = await Complaint.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$priority",
        count: { $sum: 1 },
      },
    },
  ]);

  // Resolution time metrics (in hours)
  const resolutionMetrics = await Complaint.aggregate([
    {
      $match: {
        ...filter,
        status: "resolved",
        resolutionDate: { $exists: true },
      },
    },
    {
      $project: {
        resolutionHours: {
          $divide: [
            { $subtract: ["$resolutionDate", "$createdAt"] },
            1000 * 60 * 60, // Convert to hours
          ],
        },
      },
    },
    {
      $group: {
        _id: null,
        avgResolutionTime: { $avg: "$resolutionHours" },
        minResolutionTime: { $min: "$resolutionHours" },
        maxResolutionTime: { $max: "$resolutionHours" },
      },
    },
  ]);

  // High priority complaints
  const highPriorityCount = await Complaint.countDocuments({
    ...filter,
    priority: "high",
  });

  // Per hostel
  const complaintsByHostel = await Complaint.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$hostel",
        count: { $sum: 1 },
      },
    },
    {
      $lookup: {
        from: "hostels",
        localField: "_id",
        foreignField: "_id",
        as: "hostelInfo",
      },
    },
    {
      $project: {
        hostelName: { $arrayElemAt: ["$hostelInfo.name", 0] },
        count: 1,
      },
    },
    { $sort: { count: -1 } },
  ]);

  const report = {
    summary: {
      totalComplaints,
      highPriority: highPriorityCount,
    },
    byStatus: complaintsByStatus,
    byCategory: complaintsByCategory,
    byPriority: complaintsByPriority,
    byHostel: complaintsByHostel,
    resolutionMetrics: {
      avgResolutionHours: resolutionMetrics[0]?.avgResolutionTime || 0,
      minResolutionHours: resolutionMetrics[0]?.minResolutionTime || 0,
      maxResolutionHours: resolutionMetrics[0]?.maxResolutionTime || 0,
    },
  };

  logger.info(`Complaint report generated by ${req.user._id}`);

  return res.status(200).json(
    new ApiResponse(200, report, "Complaint report generated successfully")
  );
});

/**
 * User Report
 * Shows user statistics and engagement metrics
 */
const getUserReport = asyncHandler(async (req, res) => {
  const { startDate, endDate } = req.query;

  // Build date filter
  let dateFilter = {};
  if (startDate || endDate) {
    dateFilter.createdAt = {};
    if (startDate) {
      dateFilter.createdAt.$gte = new Date(startDate);
    }
    if (endDate) {
      dateFilter.createdAt.$lte = new Date(endDate);
    }
  }

  // Total active users
  const totalUsers = await User.countDocuments(dateFilter);

  // Users by role
  const usersByRole = await User.aggregate([
    { $match: dateFilter },
    {
      $group: {
        _id: "$role",
        count: { $sum: 1 },
      },
    },
  ]);

  // Users by account status
  const usersByStatus = await User.aggregate([
    { $match: dateFilter },
    {
      $group: {
        _id: "$accountStatus",
        count: { $sum: 1 },
      },
    },
  ]);

  // Top customers by bookings
  const topCustomers = await Booking.aggregate([
    {
      $match: dateFilter,
    },
    {
      $group: {
        _id: "$user",
        bookingCount: { $sum: 1 },
        totalSpent: { $sum: "$totalPrice" },
      },
    },
    {
      $lookup: {
        from: "users",
        localField: "_id",
        foreignField: "_id",
        as: "userInfo",
      },
    },
    {
      $project: {
        userName: { $arrayElemAt: ["$userInfo.name", 0] },
        userEmail: { $arrayElemAt: ["$userInfo.email", 0] },
        bookingCount: 1,
        totalSpent: 1,
      },
    },
    { $sort: { bookingCount: -1 } },
    { $limit: 10 },
  ]);

  // Repeat customers (users with 2+ bookings)
  const repeatCustomersCount = await Booking.aggregate([
    { $match: dateFilter },
    {
      $group: {
        _id: "$user",
        bookingCount: { $sum: 1 },
      },
    },
    {
      $match: { bookingCount: { $gte: 2 } },
    },
    {
      $count: "repeatCount",
    },
  ]);

  const repeatCount = repeatCustomersCount[0]?.repeatCount || 0;
  const repeatRate =
    totalUsers > 0 ? ((repeatCount / totalUsers) * 100).toFixed(2) : 0;

  // Monthly user growth
  const monthlyUserGrowth = await User.aggregate([
    { $match: dateFilter },
    {
      $group: {
        _id: {
          year: { $year: "$createdAt" },
          month: { $month: "$createdAt" },
        },
        newUsers: { $sum: 1 },
      },
    },
    { $sort: { "_id.year": 1, "_id.month": 1 } },
  ]);

  const report = {
    summary: {
      totalUsers,
      repeatCustomers: repeatCount,
      repeatRate: `${repeatRate}%`,
    },
    byRole: usersByRole,
    byStatus: usersByStatus,
    topCustomers,
    monthlyGrowth: monthlyUserGrowth,
  };

  logger.info(`User report generated by ${req.user._id}`);

  return res.status(200).json(
    new ApiResponse(200, report, "User report generated successfully")
  );
});

/**
 * Revenue Report
 * Shows financial metrics and revenue breakdown
 */
const getRevenueReport = asyncHandler(async (req, res) => {
  const { startDate, endDate, hostelId } = req.query;

  // Build filter
  let filter = { status: "completed" };
  if (startDate || endDate) {
    filter.createdAt = {};
    if (startDate) {
      filter.createdAt.$gte = new Date(startDate);
    }
    if (endDate) {
      filter.createdAt.$lte = new Date(endDate);
    }
  }
  if (hostelId) {
    filter.hostel = hostelId;
  }

  // Total revenue
  const totalRevenueData = await Payment.aggregate([
    { $match: filter },
    {
      $group: {
        _id: null,
        totalRevenue: { $sum: "$amount" },
        totalTransactions: { $sum: 1 },
      },
    },
  ]);

  const totalRevenue = totalRevenueData[0]?.totalRevenue || 0;
  const totalTransactions = totalRevenueData[0]?.totalTransactions || 0;

  // Monthly revenue
  const monthlyRevenue = await Payment.aggregate([
    { $match: filter },
    {
      $group: {
        _id: {
          year: { $year: "$createdAt" },
          month: { $month: "$createdAt" },
        },
        revenue: { $sum: "$amount" },
        transactions: { $sum: 1 },
      },
    },
    { $sort: { "_id.year": 1, "_id.month": 1 } },
  ]);

  // Revenue by hostel
  const revenueByHostel = await Booking.aggregate([
    { $match: { ...filter, status: { $in: ["completed", "checked_out"] } } },
    {
      $group: {
        _id: "$hostel",
        revenue: { $sum: "$totalPrice" },
      },
    },
    {
      $lookup: {
        from: "hostels",
        localField: "_id",
        foreignField: "_id",
        as: "hostelInfo",
      },
    },
    {
      $project: {
        hostelName: { $arrayElemAt: ["$hostelInfo.name", 0] },
        accountStatus: { $arrayElemAt: ["$hostelInfo.accountStatus", 0] },
        revenue: 1,
      },
    },
    { $sort: { revenue: -1 } },
  ]);

  // Active vs Inactive hostels revenue
  const hostelRevenue = await Hostel.aggregate([
    {
      $lookup: {
        from: "bookings",
        localField: "_id",
        foreignField: "hostel",
        as: "bookings",
      },
    },
    {
      $project: {
        accountStatus: 1,
        _id: 1,
        revenue: {
          $sum: "$bookings.totalPrice",
        },
      },
    },
    {
      $group: {
        _id: "$accountStatus",
        totalRevenue: { $sum: "$revenue" },
        hostelCount: { $sum: 1 },
      },
    },
  ]);

  const report = {
    summary: {
      totalRevenue,
      totalTransactions,
      avgTransactionValue:
        totalTransactions > 0
          ? (totalRevenue / totalTransactions).toFixed(2)
          : 0,
    },
    monthly: monthlyRevenue,
    byHostel: revenueByHostel,
    activeVsInactive: hostelRevenue,
  };

  logger.info(`Revenue report generated by ${req.user._id}`);

  return res.status(200).json(
    new ApiResponse(200, report, "Revenue report generated successfully")
  );
});

module.exports = {
  getBookingReport,
  getComplaintReport,
  getUserReport,
  getRevenueReport,
};
